(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.slippyTile = factory());
}(this, (function () {

var natgeo = {
  name: 'ESRI National Geographic World Map',
  categories: [
    'esri',
    'national',
    'geographic',
    'world'
  ],
  url: 'https://services.arcgisonline.com/arcgis/rest/services/NatGeo_World_Map/MapServer/WMTS/tile/1.0.0/World_Imagery/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpg',
  description: 'This map is designed to be used as a general reference map for informational and educational purposes as well as a basemap by GIS professionals and other users for creating web maps and web mapping applications.',
  attribution: 'National Geographic, Esri, DeLorme, HERE, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, INCREMENT P',
  format: 'jpg',
  type: 'baselayer'
};

var ocean = {
  name: 'ESRI Ocean Basemap',
  categories: [
    'esri',
    'ocean',
    'world'
  ],
  url: 'https://services.arcgisonline.com/arcgis/rest/services/Ocean_Basemap/MapServer/WMTS/tile/1.0.0/World_Imagery/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpg',
  description: 'The ocean basemap includes bathymetry, surface and subsurface feature names, and derived depths. This service is designed to be used as a basemap by marine GIS professionals and as a reference map by anyone interested in ocean data.',
  attribution: 'Esri, GEBCO, NOAA, National Geographic, DeLorme, HERE, Geonames.org, and other contributors',
  format: 'jpg',
  type: 'baselayer'
};

var usatopo = {
  name: 'ESRI USA Topo Maps',
  categories: [
    'esri',
    'topo',
    'topographicusa'
  ],
  url: 'https://services.arcgisonline.com/arcgis/rest/services/USA_Topo_Maps/MapServer/WMTS/tile/1.0.0/World_Imagery/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpg',
  description: 'This map service presents detailed USGS topographic maps for the United States at multiple scales.',
  attribution: '© 2011 National Geographic Society, i-cubed',
  format: 'jpg',
  type: 'baselayer'
};

var imagery = {
  name: 'ESRI World Imagery',
  categories: [
    'esri',
    'imagery',
    'world'
  ],
  url: 'https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/WMTS/tile/1.0.0/World_Imagery/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpg',
  description: 'This map service presents satellite imagery for the world and high-resolution imagery for the United States and other areas around the world.',
  attribution: 'Esri, DigitalGlobe, Earthstar Geographics, CNES/Airbus DS, GeoEye, USDA FSA, USGS, Getmapping, Aerogrid, IGN, IGP, and the GIS User Community',
  format: 'jpg',
  type: 'baselayer'
};

var street = {
  name: 'ESRI World Street Map',
  categories: [
    'esri',
    'street',
    'world'
  ],
  url: 'https://services.arcgisonline.com/arcgis/rest/services/World_Street_Map/MapServer/WMTS/tile/1.0.0/World_Topo_Map/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpg',
  description: 'This map service presents highway-level data for the world and street-level data for North America, Europe, Africa, parts of the Middle East, Asia, and more.',
  attribution: 'Esri, HERE, DeLorme, USGS, Intermap, INCREMENT P, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), MapmyIndia, © OpenStreetMap contributors, and the GIS User Community',
  format: 'jpg',
  type: 'baselayer'
};

var topo = {
  name: 'ESRI World Topographic Map',
  categories: [
    'esri',
    'topo',
    'topographic',
    'world'
  ],
  url: 'https://services.arcgisonline.com/arcgis/rest/services/World_Topo_Map/MapServer/WMTS/tile/1.0.0/World_Imagery/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpg',
  description: 'This world topographic map includes boundaries, cities, water features, physiographic features, parks, landmarks, transportation, and buildings.',
  attribution: 'Esri, HERE, DeLorme, Intermap, INCREMENT P, GEBCO, USGS, FAO, NPS, NRCAN, GeoBase, IGN, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), swisstopo, MapmyIndia, © OpenStreetMap contributors, GIS User Community',
  format: 'jpg',
  type: 'baselayer'
};

var esri = {
	natgeo: natgeo,
	ocean: ocean,
	usatopo: usatopo,
	imagery: imagery,
	street: street,
	topo: topo
};

var imagery$1 = {
  name: 'Bing Imagery',
  categories: [
    'bing',
    'imagery',
    'world'
  ],
  url: 'https://ecn.t{switch:0,1,2,3}.tiles.virtualearth.net/tiles/a{quadkey}.jpeg?g=5250',
  description: 'Tiles from Bing',
  attribution: 'Map data © Bing',
  format: 'jpg',
  type: 'baselayer'
};

var bing = {
	imagery: imagery$1
};

var standard = {
  name: 'OpenStreetMap Standard',
  categories: [
    'openstreetmap',
    'standard',
    'world'
  ],
  url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
  description: 'Tiles from OpenStreetMap',
  attribution: 'Map data © OpenStreetMap',
  format: 'png',
  type: 'baselayer'
};

var cycle = {
  name: 'OpenStreetMap Cycle Map',
  categories: [
    'openstreetmap',
    'cycle',
    'world'
  ],
  url: 'https://{s}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png',
  description: 'Tiles from OpenStreetMap',
  attribution: 'Map data © OpenStreetMap',
  format: 'png',
  type: 'baselayer'
};

var hot = {
  name: 'OpenStreetMap Humanitarian',
  categories: [
    'openstreetmap',
    'hot',
    'humanitarian',
    'world'
  ],
  url: 'https://tile-{s}.openstreetmap.fr/hot/{z}/{x}/{y}.png',
  description: 'Tiles from OpenStreetMap',
  attribution: 'Map data © OpenStreetMap',
  format: 'png',
  type: 'baselayer'
};

var transport = {
  name: 'OpenStreetMap Transport Map',
  categories: [
    'openstreetmap',
    'transport',
    'world'
  ],
  url: 'https://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png',
  description: 'Tiles from OpenStreetMap',
  attribution: 'Map data © OpenStreetMap',
  format: 'png',
  type: 'baselayer'
};

var wikimedia = {
  name: 'OpenStreetMap Wikimedia',
  categories: [
    'openstreetmap',
    'wikimedia',
    'world'
  ],
  url: 'https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}.png',
  description: 'Tiles from OSM',
  attribution: 'Map data © OSM',
  format: 'png',
  type: 'baselayer'
};

var lyrk = {
  name: 'OpenStreetMap Lyrk',
  categories: [
    'openstreetmap',
    'lyrk',
    'world'
  ],
  url: 'https://tiles.lyrk.org/ls/{z}/{x}/{y}?apikey=6e8cfef737a140e2a58c8122aaa26077',
  description: 'Tiles from OpenStreetMap',
  attribution: 'Map data © OpenStreetMap',
  format: 'png',
  type: 'baselayer'
};

var openstreetmap = {
	standard: standard,
	cycle: cycle,
	hot: hot,
	transport: transport,
	wikimedia: wikimedia,
	lyrk: lyrk
};

var index$2 = {
  esri: esri,
  bing: bing,
  openstreetmap: openstreetmap
};

var originShift = 2 * Math.PI * 6378137 / 2.0;
function initialResolution (tileSize) {
  tileSize = tileSize || 256;
  return 2 * Math.PI * 6378137 / tileSize
}

/**
 * Hash tile for unique id key
 *
 * @param {Tile} tile [x, y, z]
 * @returns {number} hash
 * @example
 * var id = mercator.hash([312, 480, 4])
 * //=5728
 */
function hash (tile) {
  var x = tile[0];
  var y = tile[1];
  var z = tile[2];
  return (1 << z) * ((1 << z) + x) + y
}

/**
 * Converts BBox to Center
 *
 * @param {BBox} bbox - [west, south, east, north] coordinates
 * @return {LngLat} center
 * @example
 * var center = mercator.bboxToCenter([90, -45, 85, -50])
 * //= [ 87.5, -47.5 ]
 */
function bboxToCenter (bbox) {
  var west = bbox[0];
  var south = bbox[1];
  var east = bbox[2];
  var north = bbox[3];
  var lng = (west - east) / 2 + east;
  var lat = (south - north) / 2 + north;
  lng = Number(lng.toFixed(6));
  lat = Number(lat.toFixed(6));
  return [lng, lat]
}

/**
 * Converts LngLat coordinates to Meters coordinates.
 *
 * @param {LngLat} lnglat Longitude (Meridians) & Latitude (Parallels) in decimal degrees
 * @param {boolean} [validate=false] validates LatLng coordinates
 * @returns {Meters} Meters coordinates
 * @example
 * var meters = mercator.lngLatToMeters([126, 37])
 * //=[ 14026255.8, 4439106.7 ]
 */
function lngLatToMeters (lnglat, validate) {
  if (validate) validateLngLat(lnglat);
  var lng = lnglat[0];
  var lat = lnglat[1];
  var x = lng * originShift / 180.0;
  var y = Math.log(Math.tan((90 + lat) * Math.PI / 360.0)) / (Math.PI / 180.0);
  y = y * originShift / 180.0;
  x = Number(x.toFixed(1));
  y = Number(y.toFixed(1));
  return [x, y]
}

/**
 * Converts Meters coordinates to LngLat coordinates.
 *
 * @param {Meters} meters Meters in Mercator [x, y]
 * @returns {LngLat} LngLat coordinates
 * @example
 * var lnglat = mercator.metersToLngLat([14026255, 4439106])
 * //=[ 126, 37 ]
 */
function metersToLngLat (meters) {
  var x = meters[0];
  var y = meters[1];
  var lng = (x / originShift) * 180.0;
  var lat = (y / originShift) * 180.0;
  lat = 180 / Math.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180.0)) - Math.PI / 2.0);
  lng = Number(lng.toFixed(6));
  lat = Number(lat.toFixed(6));
  return [lng, lat]
}

/**
 * Converts Meters coordinates to Pixels coordinates.
 *
 * @param {Meters} meters Meters in Mercator [x, y]
 * @param {number} zoom Zoom level
 * @param {number} [tileSize=256] Tile size
 * @returns {Pixels} Pixels coordinates
 * @example
 * var pixels = mercator.metersToPixels([14026255, 4439106], 13)
 * //=[ 1782579.1, 1280877.3, 13 ]
 */
function metersToPixels (meters, zoom, tileSize) {
  var x = meters[0];
  var y = meters[1];
  var res = resolution(zoom, tileSize);
  var px = (x + originShift) / res;
  var py = (y + originShift) / res;
  return [px, py, zoom]
}

/**
 * Converts LngLat coordinates to TMS Tile.
 *
 * @param {LngLat} lnglat Longitude (Meridians) & Latitude (Parallels) in decimal degrees
 * @param {number} zoom Zoom level
 * @param {boolean} [validate=false] validates LatLng coordinates
 * @returns {Tile} TMS Tile
 * @example
 * var tile = mercator.lngLatToTile([126, 37], 13)
 * //=[ 6963, 5003, 13 ]
 */
function lngLatToTile (lnglat, zoom, validate) {
  if (validate) validateLngLat(lnglat);
  var meters = lngLatToMeters(lnglat);
  var pixels = metersToPixels(meters, zoom);
  return pixelsToTile(pixels)
}

/**
 * Converts LngLat coordinates to Google (XYZ) Tile.
 *
 * @param {LngLat} lnglat Longitude (Meridians) & Latitude (Parallels) in decimal degrees
 * @param {number} zoom Zoom level
 * @param {boolean} [validate=false] validates LatLng coordinates
 * @returns {Google} Google (XYZ) Tile
 * @example
 * var google = mercator.lngLatToGoogle([126, 37], 13)
 * //=[ 6963, 3188, 13 ]
 */
function lngLatToGoogle (lnglat, zoom, validate) {
  if (validate) validateLngLat(lnglat);

  if (zoom === 0) {
    return [0, 0, 0]
  }
  var tile = lngLatToTile(lnglat, zoom);
  return tileToGoogle(tile)
}

/**
 * Converts Meters coordinates to TMS Tile.
 *
 * @param {Meters} meters Meters in Mercator [x, y]
 * @param {number} zoom Zoom level
 * @returns {Tile} TMS Tile
 * @example
 * var tile = mercator.metersToTile([14026255, 4439106], 13)
 * //=[ 6963, 5003, 13 ]
 */
function metersToTile (meters, zoom) {
  if (zoom === 0) {
    return [0, 0, 0]
  }
  var pixels = metersToPixels(meters, zoom);
  return pixelsToTile(pixels)
}

/**
 * Converts Pixels coordinates to Meters coordinates.
 *
 * @param {Pixels} pixels Pixels [x, y, zoom]
 * @param {number} [tileSize=256] Tile size
 * @param {boolean} [validate=false] validates Pixels coordinates
 * @returns {Meters} Meters coordinates
 * @example
 * var meters = mercator.pixelsToMeters([1782579, 1280877, 13])
 * //=[ 14026252.0, 4439099.5 ]
 */
function pixelsToMeters (pixels, tileSize, validate) {
  if (validate) validatePixels(pixels);

  var px = pixels[0];
  var py = pixels[1];
  var zoom = pixels[2];
  var res = resolution(zoom, tileSize);
  var mx = px * res - originShift;
  var my = py * res - originShift;
  mx = Number(mx.toFixed(1));
  my = Number(my.toFixed(1));
  return [mx, my]
}

/**
 * Converts Pixels coordinates to TMS Tile.
 *
 * @param {Pixels} pixels Pixels [x, y, zoom]
 * @param {number} [tileSize=256] Tile size
 * @param {boolean} [validate=false] validates Pixels coordinates
 * @returns {Tile} TMS Tile
 * @example
 * var tile = mercator.pixelsToTile([1782579, 1280877, 13])
 * //=[ 6963, 5003, 13 ]
 */
function pixelsToTile (pixels, tileSize, validate) {
  if (validate) validatePixels(pixels);
  tileSize = tileSize || 256;
  var px = pixels[0];
  var py = pixels[1];
  var zoom = pixels[2];
  if (zoom === 0) {
    return [0, 0, 0]
  }
  var tx = Math.ceil(px / tileSize) - 1;
  var ty = Math.ceil(py / tileSize) - 1;
  if (tx < 0) {
    tx = 0;
  }
  if (ty < 0) {
    ty = 0;
  }
  return [tx, ty, zoom]
}

/**
 * Converts TMS Tile to bbox in Meters coordinates.
 *
 * @param {Tile} tile Tile [x, y, zoom]
 * @param {number} x TMS Tile X
 * @param {number} y TMS Tile Y
 * @param {number} zoom Zoom level
 * @param {number} [tileSize=256] Tile size
 * @param {boolean} [validate=false] validates Tile
 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @example
 * var bbox = mercator.tileToBBoxMeters([6963, 5003, 13])
 * //=[ 14025277.4, 4437016.6, 14030169.4, 4441908.5 ]
 */
function tileToBBoxMeters (tile, tileSize, validate) {
  if (validate) validateTile(tile);

  tileSize = tileSize || 256;
  var tx = tile[0];
  var ty = tile[1];
  var zoom = tile[2];
  var min = pixelsToMeters([tx * tileSize, ty * tileSize, zoom]);
  var max = pixelsToMeters([(tx + 1) * tileSize, (ty + 1) * tileSize, zoom]);
  return [min[0], min[1], max[0], max[1]]
}

/**
 * Converts TMS Tile to bbox in LngLat coordinates.
 *
 * @param {Tile} tile Tile [x, y, zoom]
 * @param {number} x TMS Tile X
 * @param {number} y TMS Tile Y
 * @param {number} zoom Zoom level
 * @param {boolean} [validate=false] validates Tile
 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @example
 * var bbox = mercator.tileToBBox([6963, 5003, 13])
 * //=[ 125.991, 36.985, 126.035, 37.020 ]
 */
function tileToBBox (tile, validate) {
  if (validate) validateTile(tile);

  var tx = tile[0];
  var ty = tile[1];
  var zoom = tile[2];
  if (zoom === 0) {
    return [-180, -85.051129, 180, 85.051129]
  }
  var bbox = tileToBBoxMeters([tx, ty, zoom]);
  var mx1 = bbox[0];
  var my1 = bbox[1];
  var mx2 = bbox[2];
  var my2 = bbox[3];
  var min = metersToLngLat([mx1, my1, zoom]);
  var max = metersToLngLat([mx2, my2, zoom]);
  return [min[0], min[1], max[0], max[1]]
}

/**
 * Converts Google (XYZ) Tile to bbox in Meters coordinates.
 *
 * @param {Google} google Google [x, y, zoom]
 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @example
 * var bbox = mercator.googleToBBoxMeters([6963, 3188, 13])
 * //=[ 14025277.4, 4437016.6, 14030169.4, 4441908.5 ]
 */
function googleToBBoxMeters (google) {
  var Tile = googleToTile$1(google);
  return tileToBBoxMeters(Tile)
}

/**
 * Converts Google (XYZ) Tile to bbox in LngLat coordinates.
 *
 * @param {Google} google Google [x, y, zoom]
 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @example
 * var bbox = mercator.googleToBBox([6963, 3188, 13])
 * //=[ 125.991, 36.985, 126.035, 37.020 ]
 */
function googleToBBox$1 (google) {
  var Tile = googleToTile$1(google);
  return tileToBBox(Tile)
}

/**
 * Converts TMS Tile to Google (XYZ) Tile.
 *
 * @param {Tile} tile Tile [x, y, zoom]
 * @param {boolean} [validate=false] validates Tile
 * @returns {Google} Google (XYZ) Tile
 * @example
 * var google = mercator.tileToGoogle([6963, 5003, 13])
 * //=[ 6963, 3188, 13 ]
 */
function tileToGoogle (tile, validate) {
  if (validate) validateTile(tile);

  var tx = tile[0];
  var ty = tile[1];
  var zoom = tile[2];
  if (zoom === 0) {
    return [0, 0, 0]
  }
  var x = tx;
  var y = (Math.pow(2, zoom) - 1) - ty;
  return [x, y, zoom]
}

/**
 * Converts Google (XYZ) Tile to TMS Tile.
 *
 * @param {Google} google Google [x, y, zoom]
 * @returns {Tile} TMS Tile
 * @example
 * var tile = mercator.googleToTile([6963, 3188, 13])
 * //=[ 6963, 5003, 13 ]
 */
function googleToTile$1 (google) {
  var x = google[0];
  var y = google[1];
  var zoom = google[2];
  var tx = x;
  var ty = Math.pow(2, zoom) - y - 1;
  return [tx, ty, zoom]
}

/**
 * Converts Google (XYZ) Tile to Quadkey.
 *
 * @param {Google} google Google [x, y, zoom]
 * @returns {string} Microsoft's Quadkey schema
 * @example
 * var quadkey = mercator.googleToQuadkey([6963, 3188, 13])
 * //='1321102330211'
 */
function googleToQuadkey$1 (google) {
  var Tile = googleToTile$1(google);
  return tileToQuadkey(Tile)
}

/**
 * Converts TMS Tile to QuadKey.
 *
 * @param {Tile} tile Tile [x, y, zoom]
 * @param {boolean} [validate=false] validates Tile
 * @returns {string} Microsoft's Quadkey schema
 * @example
 * var quadkey = mercator.tileToQuadkey([6963, 5003, 13])
 * //='1321102330211'
 */
function tileToQuadkey (tile, validate) {
  if (validate) validateTile(tile);

  var tx = tile[0];
  var ty = tile[1];
  var zoom = tile[2];
  // Zoom 0 does not exist for Quadkey
  if (zoom === 0) {
    return ''
  }
  var quadkey = '';
  ty = (Math.pow(2, zoom) - 1) - ty;
  range(zoom, 0, -1).map(function (i) {
    var digit = 0;
    var mask = 1 << (i - 1);
    if ((tx & mask) !== 0) {
      digit += 1;
    }
    if ((ty & mask) !== 0) {
      digit += 2;
    }
    quadkey = quadkey.concat(digit);
  });
  return quadkey
}

/**
 * Converts Quadkey to TMS Tile.
 *
 * @param {string} quadkey Microsoft's Quadkey schema
 * @returns {Tile} TMS Tile
 * @example
 * var tile = mercator.quadkeyToTile('1321102330211')
 * //=[ 6963, 5003, 13 ]
 */
function quadkeyToTile (quadkey) {
  var Google = quadkeyToGoogle(quadkey);
  return googleToTile$1(Google)
}

/**
 * Converts Quadkey to Google (XYZ) Tile.
 *
 * @param {string} quadkey Microsoft's Quadkey schema
 * @returns {Google} Google (XYZ) Tile
 * @example
 * var google = mercator.quadkeyToGoogle('1321102330211')
 * //=[ 6963, 3188, 13 ]
 */
function quadkeyToGoogle (quadkey) {
  var x = 0;
  var y = 0;
  var zoom = quadkey.length;
  range(zoom, 0, -1).map(function (i) {
    var mask = 1 << (i - 1);
    switch (parseInt(quadkey[zoom - i], 0)) {
      case 0:
        break
      case 1:
        x += mask;
        break
      case 2:
        y += mask;
        break
      case 3:
        x += mask;
        y += mask;
        break
      default:
        throw new Error('Invalid Quadkey digit sequence')
    }
  });
  return [x, y, zoom]
}

/**
 * Converts BBox from LngLat coordinates to Meters coordinates
 *
 * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @example
 * var meters = mercator.bboxToMeters([ 125, 35, 127, 37 ])
 * //=[ 13914936.3, 4163881.1, 14137575.3, 4439106.7 ]
 */
function bboxToMeters$1 (bbox) {
  var min = lngLatToMeters([bbox[0], bbox[1]]);
  var max = lngLatToMeters([bbox[2], bbox[3]]);
  return [min[0], min[1], max[0], max[1]]
}

/**
 * Validates TMS Tile.
 *
 * @param {Tile} tile Tile [x, y, zoom]
 * @throws {Error} Will throw an error if TMS Tile is not valid.
 * @returns {Tile} TMS Tile
 * @example
 * mercator.validateTile([60, 80, 12])
 * //=[60, 80, 12]
 * mercator.validateTile([60, -43, 5])
 * //= Error: Tile <y> must not be less than 0
 * mercator.validateTile([25, 60, 3])
 * //= Error: Illegal parameters for tile
 */
function validateTile (tile) {
  var tx = tile[0];
  var ty = tile[1];
  var zoom = tile[2];
  validateZoom(zoom);
  if (tx === undefined || tx === null) { throw new Error('<x> is required') }
  if (ty === undefined || ty === null) { throw new Error('<y> is required') }
  if (tx < 0) { throw new Error('<x> must not be less than 0') }
  if (ty < 0) { throw new Error('<y> must not be less than 0') }
  var maxCount = Math.pow(2, zoom);
  if (tx >= maxCount || ty >= maxCount) { throw new Error('Illegal parameters for tile') }
  return tile
}

/**
 * Validates Zoom level
 *
 * @param {number} zoom Zoom level
 * @throws {Error} Will throw an error if zoom is not valid.
 * @returns {number} zoom Zoom level
 * @example
 * mercator.validateZoom(12)
 * //=12
 * mercator.validateZoom(-4)
 * //= Error: <zoom> cannot be less than 0
 * mercator.validateZoom(32)
 * //= Error: <zoom> cannot be greater than 30
 */
function validateZoom (zoom) {
  if (zoom === undefined || zoom === null) { throw new Error('<zoom> is required') }
  if (zoom < 0) { throw new Error('<zoom> cannot be less than 0') }
  if (zoom > 30) { throw new Error('<zoom> cannot be greater than 30') }
  return zoom
}

/**
 * Validates LngLat coordinates
 *
 * @param {LngLat} lnglat Longitude (Meridians) & Latitude (Parallels) in decimal degrees
 * @throws {Error} Will throw an error if LngLat is not valid.
 * @returns {LngLat} LngLat coordinates
 * @example
 * mercator.validateLngLat([-115, 44])
 * //= [ -115, 44 ]
 * mercator.validateLngLat([-225, 44])
 * //= Error: LngLat [lng] must be within -180 to 180 degrees
 */
function validateLngLat (lnglat) {
  var lng = lnglat[0];
  var lat = lnglat[1];
  if (lat === undefined || lat === null) { throw new Error('<lat> is required') }
  if (lng === undefined || lng === null) { throw new Error('<lng> is required') }
  if (lat < -90 || lat > 90) { throw new Error('LngLat <lat> must be within -90 to 90 degrees') }
  if (lng < -180 || lng > 180) { throw new Error('LngLat <lng> must be within -180 to 180 degrees') }
  return [lng, lat]
}

/**
 * Validates Pixels coordinates
 *
 * @param {Pixels} pixels Pixels [x, y, zoom]
 * @param {number} x Pixels X
 * @param {number} y Pixels Y
 * @param {number} [zoom] Zoom level
 * @throws {Error} Will throw an error if Pixels is not valid.
 * @returns {Pixels} Pixels coordinates
 * @example
 * mercator.validatePixels([-115, 44])
 */
function validatePixels (pixels) {
  // TODO
  return pixels
}

/**
 * Retrieve resolution based on zoom level
 *
 * @private
 * @param {number} zoom zoom level
 * @param {number} [tileSize=256] Tile size
 * @returns {number} resolution
 * @example
 * var res = mercator.resolution(13)
 * //=19.109257071294063
 */
function resolution (zoom, tileSize) {
  return initialResolution(tileSize) / Math.pow(2, zoom)
}

/**
 * Generate an integer Array containing an arithmetic progression.
 *
 * @private
 * @param {number} [start=0] Start
 * @param {number} stop Stop
 * @param {number} [step=1] Step
 * @returns {number[]} range
 * @example
 * mercator.range(3)
 * //=[ 0, 1, 2 ]
 * mercator.range(3, 6)
 * //=[ 3, 4, 5 ]
 * mercator.range(6, 3, -1)
 * //=[ 6, 5, 4 ]
 */
function range (start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range[idx] = start;
  }
  return range
}

/**
 * Maximum extent of BBox
 *
 * @param {BBox|BBox[]} array BBox [west, south, east, north]
 * @returns {BBox} Maximum BBox
 * @example
 * var bbox = mercator.maxBBox([[-20, -30, 20, 30], [-110, -30, 120, 80]])
 * //=[-110, -30, 120, 80]
 */
function maxBBox (array) {
  // Single BBox
  if (array && array[0] && array.length === 4 && array[0][0] === undefined) {
    return array
  }

  // Multiple BBox
  if (array && array[0] && array[0][0] !== undefined) {
    var west = array[0][0];
    var south = array[0][1];
    var east = array[0][2];
    var north = array[0][3];

    array.map(function (bbox) {
      if (bbox[0] < west) { west = bbox[0]; }
      if (bbox[1] < south) { south = bbox[1]; }
      if (bbox[2] > east) { east = bbox[2]; }
      if (bbox[3] > north) { north = bbox[3]; }
    });
    return [west, south, east, north]
  }
}

var index$4 = {
  hash,
  bboxToCenter,
  lngLatToMeters,
  metersToLngLat,
  metersToPixels,
  lngLatToTile,
  lngLatToGoogle,
  metersToTile,
  pixelsToMeters,
  pixelsToTile,
  tileToBBoxMeters,
  tileToBBox,
  googleToBBoxMeters,
  googleToBBox: googleToBBox$1,
  tileToGoogle,
  googleToTile: googleToTile$1,
  googleToQuadkey: googleToQuadkey$1,
  tileToQuadkey,
  quadkeyToTile,
  quadkeyToGoogle,
  bboxToMeters: bboxToMeters$1,
  validateTile,
  validateZoom,
  validateLngLat,
  validatePixels,
  resolution,
  range,
  maxBBox
};

const providers = index$2;
const mercator = index$4;
const googleToBBox = mercator.googleToBBox;
const googleToTile = mercator.googleToTile;
const googleToQuadkey = mercator.googleToQuadkey;
const bboxToMeters = mercator.bboxToMeters;

/**
 * Substitutes the given tile information [x, y, z] to the URL tile scheme.
 *
 * @param {Tile} tile Tile [x, y, z]
 * @param {string} url URL Tile scheme or provider unique key
 * @returns {string}
 * @example
 * slippyTile.parse([10, 15, 8], 'https://{s}.tile.openstreetmap.org/{zoom}/{x}/{y}.png')
 * //='https://c.tile.openstreetmap.org/8/10/15.png'
 */
function parse (tile, url) {
  var x = tile[0];
  var y = tile[1];
  var zoom = tile[2];
  url = wms(tile, url);
  url = wmts(url);
  url = parseSwitch(url);
  url = url.replace(/{(zoom|z|level)}/, String(zoom));
  url = url.replace(/{(x|col)}/, String(x));
  url = url.replace(/{(y|row)}/, String(y));
  if (url.match(/{-y}/)) { url = url.replace(/{-y}/, String(googleToTile(tile)[1])); }
  if (url.match(/{(quadkey|q)}/)) { url = url.replace(/{(quadkey|q)}/, googleToQuadkey(tile)); }
  if (url.match(/{.*}/)) { throw new Error('Could not completly parse URL' + url) }
  return url
}

/**
 * Parse WMS URL to friendly SlippyTile format
 *
 * @private
 * @param {Tile} tile Tile [x, y, z]
 * @param {string} url WMTS URL scheme
 * @returns {string}
 * @example
 * slippyTile.wms([10, 15, 8], 'https://<Tile Server>/?layers=imagery&SRS={proj}&WIDTH={width}&HEIGHT={height}&BBOX={bbox}')
 * //='https://<Tile Server>/?layers=imagery&SRS=EPSG:3857&WIDTH=256&HEIGHT=256&BBOX=-165.9375,82.676285,-164.53125,82.853382'
 */
function wms (tile, url) {
  url = url.replace(/{height}/gi, '256');
  url = url.replace(/{width}/gi, '256');
  url = url.replace(/{(proj|srs|crs)}/gi, 'EPSG:3857');
  var bbox;
  if (url.match(/EPSG:(3857|900913)/i)) {
    bbox = bboxToMeters(googleToBBox(tile));
  } else {
    bbox = googleToBBox(tile);
  }

  if (url.match(/{bbox}/i)) { url = url.replace(/{bbox}/gi, bbox.join(',')); }
  return url
}

/**
 * Parse WMTS URL to friendly SlippyTile URL format
 *
 * @private
 * @param {string} url WMTS URL scheme
 * @returns {string}
 * @example
 * slippyTile.wmts('https://<Tile Server>/WMTS/tile/1.0.0/Imagery/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpg')
 * //='https://<Tile Server>/WMTS/tile/1.0.0/Imagery/default/GoogleMapsCompatible/{z}/{y}/{x}.jpg'
 */
function wmts (url) {
  url = url.replace(/{TileCol}/gi, '{x}');
  url = url.replace(/{TileRow}/gi, '{y}');
  url = url.replace(/{TileMatrix}/gi, '{z}');
  url = url.replace(/{TileMatrixSet}/gi, 'GoogleMapsCompatible');
  url = url.replace(/{Style}/gi, 'default');
  return url
}

/**
 * Replaces {switch:a,b,c} with a random sample.
 *
 * @private
 * @param {string} url - URL Scheme
 * @returns {string} Parsed URL with switch replaced
 * @example
 * slippyTile.parseSwitch('http://tile-{switch:a,b,c}.openstreetmap.fr/hot/{zoom}/{x}/{y}.png')
 * //='http://tile-b.openstreetmap.fr/hot/{zoom}/{x}/{y}.png'
 */
function parseSwitch (url) {
  // Default simple switch
  if (url.match(/{s}/)) {
    return url.replace(/{s}/gi, String(sample(['a', 'b', 'c'])))
  }
  // Custom switch
  var pattern = /{switch:([a-z,\d]*)}/;
  var found = url.match(pattern);
  if (found) {
    return url.replace(pattern, String(sample(found[1].split(','))))
  }
  return url
}

/**
 * Sample an item from a given list
 *
 * @private
 * @name sample
 * @param {Array} array List of items
 * @returns {*} Single item from the list
 * @example
 * slippyTile.sample(['a', 'b', 'c'])
 * //='b'
 */
function sample (array) {
  if (array === null || array === undefined || array.length === 0) { return undefined }
  return array[Math.floor(Math.random() * array.length)]
}

var index = {parse, providers, wms, wmts, parseSwitch, sample};

return index;

})));
